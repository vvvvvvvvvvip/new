<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<style>
    .red {
        color: red;
    }
</style>
<body>
<!--音乐列表数据：
               https://vvvvvvvvvvip.github.io/dist/static/data.json-->
<div id="title">
    <h1>{{ reverseMessage }}</h1>

    <h2>{{ msg }}</h2>

    <p class="red">
        我们可以使用methods来代替computed效果上是一样的，
    </p>

    <p class="red">
        computed是基于他的依赖缓存，只有相关依赖发生改变时才会重新取值
    </p>

    <p class="red">
        methods再重新渲染的时候函数总会重新调用执行
    </p>

    <h3>{{ a }}</h3>
    <div>
        <p class="red">
            vm.$set(object,key,value)用于动态监控数据元素，<br>
            在实例创建后添加数组属性并且有响应可用该方法实现
        </p>
        <input v-model="opt" @blur="add()" placeholder=""/>
        <ul>
            <li v-for="item in arr">
                {{ item }}
            </li>
        </ul>
    </div>
    <p class="red">
        create:在模板渲染成HTML前调用，即通常初始化某些属性值，然后在渲染成视图
    </p>
    <p class="red">
        mounted:在模板渲染成HTML后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作
    </p>

    <p>{{ message }}</p>

    <select v-model="message">
        <option value="1" selected>1</option>
        <option value="2">2</option>
        <option value="3">3</option>
        <option value="4">4</option>
        <option value="5">5</option>
    </select>
    <span>selected:{{message}}</span>

    <p class="red">
        vue提供了一种更通用的方式来观察vue实例上的数据变动：侦听属性
    </p>

    <p class="red">
        虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。
    </p>
    <p class="red">
        这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。
    </p>
    <p class="red">
        当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。
    </p>
    <p>
        ask a yes/no question:
        <input type="text" v-model="question" autofocus/>
        <br>
        <span>{{ answer }}</span>
    </p>
    <p class="red">注册组件--全局注册</p>

    <p class="red">全局注册里面的data必须是一个函数形式</p>
    <my-component></my-component>
    <div>
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
        <simple-counter></simple-counter>
    </div>
    <p class="red">
        组件之间的传递：props向下传递，事件向上传递
    </p>
</div>

<script src="https://cdn.bootcss.com/vue/2.5.13/vue.min.js"></script>

<script>
    //全局注册
    var data = {
        counter: 0,
        newMsg: '泰迪式'
    }
    Vue.component('my-component', {
        template: '<div>{{ newMsg }}</div>',
        data: function() {
            return data
        }
    })

    Vue.component("simple-counter",{
        template: '<button v-on:click="counter += 1">{{ counter }}</button>',
        // 技术上 data 的确是一个函数了，因此 Vue 不会警告，
        // 但是我们却给每个组件实例返回了同一个对象的引用
        // 通过为每个组件返回全新的数据对象来进行单个组件的调用
        data: function () {
            console.log(data)
            return {
                counter: 0
            }
        }
    })
    //局部注册
//    var Child = {
//        template: '<div>A custom component!</div>'
//    }
    var vm = new Vue({
        el: "#title",
        data: {
            msg: "helloworld",
            name: "huahuahuahuahuahuahua",
            url: "jiaxing",
            arr: ['北京', '上海', '广东', '深圳'],
            opt: '',
            selected: '1',
            message: '2',
            question: '',
            answer: 'I cannot give an answer until you ask a question!'
        },
//        components: {
            // <my-component> 将只在父组件模板中可用
//            'my-component': Child
//        },
        watch: {
          //question改变时函数运行
            question: function(newQuestion,oldQuestion){
                this.answer = 'waiting for you to stop typing？'
                this.getAnswer()
            }
        },
        beforeCreate: function () {
            console.group('beforeCreate 创建前状态===============》');
            console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
            console.log("%c%s", "color:red","data   : " + this.$data); //undefined
            console.log("%c%s", "color:red","message: " + this.message)
        },
        created: function () {
            console.group('created 创建完毕状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //undefined
            console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
            console.log("%c%s", "color:red","message: " + this.message); //已被初始化
        },
        beforeMount: function () {
            console.group('beforeMount 挂载前状态===============》');
            console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
            console.log("%c%s", "color:red","message: " + this.message); //已被初始化
        },
        mounted: function () {
            console.group('mounted 挂载结束状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
            console.log("%c%s", "color:red","message: " + this.message); //已被初始化
        },
        beforeUpdate: function () {
            console.group('beforeUpdate 更新前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data);
            console.log("%c%s", "color:red","message: " + this.message);
        },
        updated: function () {
            console.group('updated 更新完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data);
            console.log("%c%s", "color:red","message: " + this.message);
        },
        beforeDestroy: function () {
            console.group('beforeDestroy 销毁前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data);
            console.log("%c%s", "color:red","message: " + this.message);
        },
        destroyed: function () {
            console.group('destroyed 销毁完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);
            console.log("%c%s", "color:red","data   : " + this.$data);
            console.log("%c%s", "color:red","message: " + this.message)
        },
        methods: {
            add:function (){
                this.$set(this.arr, this.arr.length, this.opt)
            },
            getAnswer: function(){
                if(this.question.indexOf('?')===-1){
                    this.answer = 'Question usually cantain a question mark'
                    return
                }
                this.answer = 'thinking'
                var vm = this
                axios.get('https://yesno.wtf/api')
                        .then(function(response){
                            vm.answer = _.capitalize(response.data.answer)
                        })
                        .catch(function (error) {
                            vm.answer = 'Error! Could not reach the API. ' + error
                        })
            }
         },
        computed: {
            reverseMessage: function () {
                return this.msg.split("").reverse().join("")
            },
            a: {
                get:
                        function () {
                            return this.name + "" + this.url
                        },
                set:
                        function (newValue) {
                            console.log(newValue)
                            var names = newValue.split(" ")
                            this.name = names[0]
                            this.url = names[names.length - 1]
                        }
            }
        }
    })
    vm.a = "huahuahuahuahuahuahua jiuzaijiaxing";
//    document.write("name：" + vm.name);
//    document.write("<br>");
//    document.write("url："+ vm.url);
</script>
</body>
</html>